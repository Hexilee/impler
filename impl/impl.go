package impl

import (
	"fmt"
	. "github.com/dave/jennifer/jen"
	"strings"
	"time"
)

const (
	FieldBaseUrl = "baseUrl"
	FieldHeader  = "header"
	FieldCookies = "cookies"
)

const (
	// packages
	HttpPkg = "net/http"
)

const (
	// types
	IntToken    = "int"
	StringToken = "string"
	ErrorToken  = "error"
)

const (
	// ids
	IdResp       = "resp"
	IdReq        = "req"
	IdStatusCode = "statusCode"
	IdError      = "err"
)

func Impl(service *Service, pkg string) (code string, err error) {
	var NewFunc = "New" + service.name
	var ImplName = service.name + "Impl"
	var self = strings.ToLower(service.name)

	file := NewFilePath(pkg)
	file.HeaderComment(fmt.Sprintf(`Implement for %s.%s
This file is generated by github.com/Hexilee/impler at %s
DON'T EDIT IT!
`, pkg, service.name, time.Now()))

	file.Func().Id(NewFunc).Params().Qual(pkg, service.name).Block(
		Return(Op("&").Id(ImplName).Values()),
	)

	file.Type().Id(ImplName).Struct(
		Id(FieldBaseUrl).String(),
		Id(FieldHeader).Qual(HttpPkg, "Header"),
		Id(FieldCookies).Index().Op("*").Qual(HttpPkg, "Cookie"),
	)

	for _, method := range service.methods {
		paramList := make([]Code, 0)
		resultList := make([]Code, 0)
		params := method.signature.Params()
		for i := 0; i < params.Len(); i++ {
			param := params.At(i)
			paramList = append(paramList, Id(param.Name()).Add(getQual(param.Type().String())))
		}

		results := method.signature.Results()
		for i := 0; i < results.Len(); i++ {
			result := results.At(i)
			resultList = append(resultList, getQual(result.Type().String()))
		}

		file.Func().
			Params(Id(self).Qual(pkg, ImplName)).
			Id(method.Name()).
			Params(paramList...).Params(resultList...)
	}
	code = fmt.Sprintf("%#v", file)
	return
}

// *net/http.Response -> Op("*").Qual("net/http", "Response")
func getQual(typ string) *Statement {
	switch typ {
	case IntToken:
		return Int()
	case StringToken:
		return String()
	case ErrorToken:
		return Err()
	default:
		var statement *Statement
		if strings.HasPrefix(typ, "*") {
			statement = Op("*")
			typ = typ[1:]
		}
		var pkg string
		dot := strings.LastIndex(typ, ".")
		if dot != -1 {
			pkg = typ[:dot]
			typ = typ[dot+1:]
		}

		//fmt.Printf("pkg: %s; typ: %s\n", pkg, typ)
		qual := Qual(pkg, typ)
		if statement == nil {
			statement = qual
		} else {
			statement = statement.Add(qual)
		}
		return statement
	}
}
